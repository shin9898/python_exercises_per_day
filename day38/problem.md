---

### 📝 Python基礎力強化 - Day38

---

お疲れ様です！Python基礎力強化、Day38です。前回は、`Customer`クラスと`Event`クラスを完璧に仕上げ、それぞれのクラスが持つべき責務をきちんと実装できました。特に、`Event`クラスでの登録ロジックは、複数の条件分岐を見事にクリアしていましたね。

今回は、いよいよ集大成である**`EventManager`クラスの残りのメソッドを完成**させ、これまで作成した`Customer`と`Event`クラスを統合して、より大きなシステムとして機能させることに挑戦します。これまでの学習で得た、辞書による高速検索、クラス間の連携、そして堅牢なエラーハンドリングの知識を総動員しましょう。

---

### 問題

あなたは引き続きイベント企画会社の担当者で、複数のイベントとそれに参加する顧客の情報を管理するシステムを開発しています。

以下の要件を満たすPythonコードを記述してください。

1.  **前回までに作成した `Customer` クラスと `Event` クラスを再利用または定義**してください。
    * （Day37で完成させたコードをそのまま使って構いません）
    * `Customer` クラスの属性とメソッド
    * `Event` クラスの属性とメソッド (`register_customer`, `cancel_registration` はメッセージ表示なしで `True`/`False` を返すもの)

2.  **`EventManager` クラスを完成**させてください。
    * 属性: `events` (リスト), `events_by_id` (辞書)
    * メソッド:
        * `__init__(self)`: コンストラクタ。`events` リストと `events_by_id` 辞書を初期化します。
        * `add_event(self, event: Event)`: (Day36で実装済みですが、再度確認のため)
            * 引数として `Event` クラスのインスタンスを受け取り、`events` リストと `events_by_id` 辞書に追加します。
            * 既に同じ `event_id` のイベントが登録されている場合は追加せず、「警告: イベントID『[ID]』のイベントは既に登録されています。」と表示する。
            * 成功したら、"イベント『[イベントタイトル]』が追加されました。" と表示する。
        * `find_event(self, event_id: str) -> Event | None`:
            * 引数 `event_id` (文字列) を受け取り、`self.events_by_id` 辞書を使って**該当する `Event` インスタンスを返します**。
            * 見つからなければ `None` を返す。
            * **（ヒント: これは他のメソッドから内部的に使われるヘルパーメソッドです。）**
        * `register_customer_to_event(self, customer: Customer, event_id: str)`:
            * 引数として `Customer` インスタンスと `event_id` を受け取ります。
            * まず `find_event` メソッドを使ってイベントを検索します。
            * イベントが見つかった場合、そのイベントの `register_customer` メソッドを呼び出します。
                * `register_customer` が `True` を返した場合、"『[イベントタイトル]』に顧客『[顧客名]』が登録されました。" と表示する。
                * `register_customer` が `False` を返した場合、その原因（定員オーバーか既に登録済みか）に応じて適切なメッセージを表示する。
                    * "『[イベントタイトル]』は定員に達しています。"
                    * "顧客『[顧客名]』は既に『[イベントタイトル]』に登録済みです。"
            * イベントが見つからない場合は、"イベントID『[ID]』のイベントは見つかりませんでした。" と表示する。
        * `cancel_customer_registration(self, customer_id: str, event_id: str)`:
            * 引数として `customer_id` と `event_id` を受け取ります。
            * `find_event` メソッドを使ってイベントを検索します。
            * イベントが見つかった場合、そのイベントの `cancel_registration` メソッドを呼び出します。
                * `cancel_registration` が `True` を返した場合、"『[イベントタイトル]』から顧客ID『[顧客ID]』の登録がキャンセルされました。" と表示する。
                * `cancel_registration` が `False` を返した場合、"顧客ID『[顧客ID]』は『[イベントタイトル]』に登録されていません。" と表示する。
            * イベントが見つからない場合は、"イベントID『[ID]』のイベントは見つかりませんでした。" と表示する。
        * `display_all_events_summary(self)`:
            * 登録されている全てのイベントのタイトル、日付、現在の登録人数、定員を表示する。
            * イベントが一つもない場合は、"現在、登録されているイベントはありません。" と表示する。
            * 表示は、**イベントタイトルで昇順**にソートして表示する。

3.  `__main__` ブロックで以下の処理を実行し、動作を確認してください。
    * `EventManager` のインスタンスを作成する。
    * 複数の `Customer` インスタンスと `Event` インスタンスを作成する。
    * `add_event` でイベントを `EventManager` に追加する。（重複イベントも試す）
    * `display_all_events_summary` で初期状態を確認する。
    * `register_customer_to_event` を使って、異なるイベントに顧客を登録する。
        * **成功するケース**
        * **定員オーバーになるケース**
        * **二重登録になるケース**
        * **存在しないイベントID**への登録ケース
    * 各登録試行後、`display_all_events_summary` で登録人数が更新されたことを確認する。
    * `cancel_customer_registration` を使って、登録をキャンセルする。
        * **成功するケース**
        * **存在しない顧客ID**でのキャンセルケース
        * **存在しないイベントID**でのキャンセルケース
    * 各キャンセル試行後、`display_all_events_summary` で登録人数が更新されたことを確認する。

---

この問題では、`EventManager`が`Event`クラスと`Customer`クラスのインスタンスを「協調」させて機能を実現します。特に、`find_event`メソッドを効率的に活用し、各処理の**結果に応じた適切なメッセージ表示**を行う点がポイントです。

これがPython基礎力強化の最終課題です。これまでの学習の集大成として、ぜひ力を出し切ってください！

頑張ってください！解答ができたら、コードとその説明、特に難しかった点や工夫した点などを教えてください。フィードバックさせていただきます。